<!--

author:   Andreas Heil
email:    andreas.heil@hs-heilbronn.de
version:  0.2
language: de
narrator: DE German Male

comment:  

-->

[![LiaScript](https://raw.githubusercontent.com/LiaScript/LiaScript/master/badges/course.svg)](https://LiaScript.github.io/course/?https://github.com/aheil/os) 


# Betriebssysteme

Dieser Kurs ist Teil des Bachelor Studiengangs Software Engineering (SEB) und an der Hochschule Heilbronn.

Dies ist das Repository der Kursinformationen. Diese Seiten sind als [interaktiver Kurs verfÃ¼gbar](https://liascript.github.io/course/?https://github.com/aheil/os) verfÃ¼gbar.

Die Vorlesung Betriebssysteme (262007) wird von mir sowohl im Sommer- als auch dem Wintersemester im Kurs SEB2 angeboten. Die Vorlesungssprache ist Deutsch.

Die Veranstaltung basiert dabei auf dem Buch [Operating Systems: Three Easy Pieces](http://pages.cs.wisc.edu/~remzi/OSTEP/) von Rezi H. und Andrea C. Arpaci-Dussseau.

Die Vorlesung wird dabei von mir um praktische ProgrammÃ¼bungen ergÃ¤nzt.

Veranstaltungsbegleitend empfehle ich die Ãœbungsaufgaben aus dem Buch zu bearbeiten.

Das Buch ist als [freies PDF Buch]((http://pages.cs.wisc.edu/~remzi/OSTEP/)) erhÃ¤ltlich. ZusÃ¤tzlich finden Sie Print-Exemplare in der Bibliothek bzw. in meinem Semesterapparat am Campus Sontheim.

FÃ¼r Student:innen in meinem Kurs gibt es in jedem Semester ein [ILIAS Raum](https://ilias.hs-heilbronn.de/goto.php?target=crs_360705&client_id=iliashhn) mit Forum.

## Kalender und Inhalte

| Einheit # | Datum | Thema | Hausaufgabe |
| --- | --- | --- | --- |
|  1 | - | [EinfÃ¼hrung in Git](https://liascript.github.io/course/?https://github.com/aheil/os/blob/gh-pages/lectures/01_git.md) | Git Kurs  |
|  2 | - | [Virtualisierung](https://liascript.github.io/course/?https://github.com/aheil/os/blob/gh-pages/lectures/02_virtualisierung.md) | [C Crashkurs](https://liascript.github.io/course/?https://github.com/aheil/hhn-c) |
|  3 | - | [Scheduler](https://liascript.github.io/course/?https://github.com/aheil/os/blob/gh-pages/lectures/03_virtualisierung.md) | |
|  4 | - | [Fortgeschrittene Scheduler](https://liascript.github.io/course/?https://github.com/aheil/os/blob/gh-pages/lectures/04_virtualisierung.md) | |
|  5 | - | [Speicher](https://liascript.github.io/course/?https://github.com/aheil/os/blob/gh-pages/lectures/05_speicher.md) | |
|  6 | - | [Speicherverwaltung](https://liascript.github.io/course/?https://github.com/aheil/os/blob/gh-pages/lectures/06_speicherverwaltung.md) | |
|  7 | - | [Swapping](https://liascript.github.io/course/?https://github.com/aheil/os/blob/gh-pages/lectures/07_swapping.md) | |
|  8 | - | [Threads](https://liascript.github.io/course/?https://github.com/aheil/os/blob/gh-pages/lectures/08_threads.md) | |
| 9 | - | [Semaphoren]((https://liascript.github.io/course/?https://github.com/aheil/os/blob/gh-pages/lectures/09_semaphoren.md)) | |
| 10 | - | [I/O](https://liascript.github.io/course/?https://github.com/aheil/os/blob/gh-pages/lectures/10_io.md) | |
| 11 | - | [Dateisysteme](https://liascript.github.io/course/?https://github.com/aheil/os/blob/gh-pages/lectures/11_dateisysteme.md) | |
| 12 | - | [Implementierung von Dateisystemen](https://liascript.github.io/course/?https://github.com/aheil/os/blob/gh-pages/lectures/12_dateisystemimplementierung.md) | |


## KursÃ¼bersicht

**Dozent**

Prof. Andreas Heil

**Kursnummer**

262007 (SEB/SPO4)

**Level**

Grundstudium Bachelor

**Semesterwochenstunden/ECTS**

2/3

**Workload**

- 30h Kontaktstunden/Lerneinheiten
- 90h Selbststudium

**Kurszeiten** 

* 1 Vorlesungseinheit / Woche, 90 Min. / Einheit

Die genauen Veranstaltungszeiten entnehmen Sie bitte dem aktuellen [Stundenplan](https://splan.hs-heilbronn.de/). 

**Voraussetzungen**

Grundlegende Programmierkenntnisse als auch ein grundlegendes VerstÃ¤ndnis fÃ¼r das Themengebiet der Informatik sind hilfreich.  

Sie sollten daher die Veranstaltung *261703 Interaktive Programme* als auch *261701 Grundlagen der Informatik* besucht und erfolgreich bestanden haben. 


**Beschreibung**

Die Studierenden kennen Aufgaben, Architektur, Komponenten und Funktionsweise sowie Klassifikationen von klassischen und modernen Betriebssystemen und haben grundlegende praktische Erfahrung mit unterschiedlichen aktuellen Betriebssystemen.

- Sie wissen, wie Prozesse oder Threads beschrieben und
kontrolliert werden kÃ¶nnen.
- Sie sind in der Lage mit NebenlÃ¤ufigkeit in eigenen Anwendungen umzugehen und die bekannten SynchronisationsmÃ¶glichkeiten sowie Verfahren zur Vermeidung, Umgehung oder AuflÃ¶sung von Deadlocks korrekt einzusetzen.
- Die Studierenden kennen die wichtigsten Verfahren und Strategien des Speichermanagements sowie unterschiedliche Scheduling-Methoden, und sie sind in der Lage, diese in eigenen Anwendungen vorteilhaft einzusetzen.
- Sie kÃ¶nnen die Eignung verschiedener Betriebssysteme oder Betriebssystemkonzepte fÃ¼r neue Anwendungen, Systemanforderungen oder Rechnerarchitekturen einschÃ¤tzen.

**Vorlesung**

Jede Vorlesung behandelt ein spezielles Thema. 

Die Veranstaltung basiert dabei auf dem Buch Operating Systems: Three Easy Pieces von Rezi H. und Andrea C. Arpaci-Dussseau.

Veranstaltungsbegleitend empfehle ich die Ãœbungsaufgaben aus dem Buch zu bearbeiten.

**Klausur**

Nach der Vorlesung findet im PrÃ¼fungszeitraum eine abschlieÃŸende Klausur statt. 
Die Klausur muss mit mindestens einer 4.0 bestanden werden, um den Kurs insgesamt zu bestehen.  

Die Dauer der Klausur betrÃ¤gt 90 Minuten. 

Das Klausurergebnis geht dabei mit insgesamt 70% in die Bewertung der Gesamtnote ein.

**Hausaufgaben**

Es gibt nicht bewertete Ãœbungen bzw. Hausaufgaben zu jedem Buchkapitel. Ich empfehle die Aufgaben in kleineren Lerngruppen zu bearbeiten und die Themen so aus der Vorlesung zu vertiefen.

ZusÃ¤tzlich gibt es zu manchen Vorlesungseinheiten Tutorials oder Ãœbungen, die optimalerweise im Selbststudium erarbeitet werden.

Insgesamt gibt es drei C ProgrammierÃ¼bungen, die von Ihnen in einer kleinen Gruppe bearbeitet werden. 

Die GruppengrÃ¶ÃŸen sind abhÃ¤ngig von der jeweiligen KursgrÃ¶ÃŸe (2er- bis 4er-Gruppen). Die Gruppen bleiben bis zum Ende des Vorlesungszeitraums fÃ¼r alle Abgaben bestehen. Die Kurse werden nach der ersten Vorlesungseinheit zufÃ¤llig festgelegt und bekanntgegeben.
Die Programmieraufgaben werden durch die Team-Mitglieder in GitLab eingecheckt und mit dem hochschuleigenen Commit-System eingereicht. 
Die Programmieraufgaben werden zu einer gegebenen Deadline eingereicht. Nachfristen werden nicht gewÃ¤hrt. Einreichungen auf anderem Weg als der oben beschriebene, werden nicht gewertet.

Die Ergebnisse der ProgrammierÃ¼bungen gehen mit insgesamt 30% in die Gesamtnote ein.

**Abgaben**

SÃ¤mtliche Abgaben erfolgen Ã¼ber das fakultÃ¤tsinterne Commit-System unter [https://commit.it.hs-heilbronn.de](https://commit.it.hs-heilbronn.de).
Das Commit-System ist nur aus dem Hochschulnetz bzw. Ã¼ber VPN erreichbar.

* Link zum Commit-System: [https://commit.it.hs-heilbronn.de](https://commit.it.hs-heilbronn.de) (nur im Hochschulnetz oder via VPN)
* Link zu GitLab: [https://gitlab.it.hs-heilbronn.de](https://gitlab.it.hs-heilbronn.de)

Zur Abgabe ist es erforderlich, dass die Aufgaben zuvor im hochschuleigenen GitLab unter [https://gitlab.it.hs-heilbronn.de](https://gitlab.it.hs-heilbronn.de) eingecheckt werden. ZugÃ¤nge zu dem System werden in den ersten drei Wochen des Semesters ausgegeben.


**Benotung**

Die Note ergibt sich aus insgesamt 100 Punkten: 

<!-- data-type="none"  -->
| AktivitÃ¤ten | Anteil an der Note |
| --- | --- | 
| Programmieraufgaben | 30% |
| Klausur | 70 % | 

FÃ¼r das Bestehen des Kurses ist das Bestehen der Klausur mit mind. einer 4,0 erforderlich.

Durch Nichteinreichen der Programmieraufgaben (oder Ergebnisse schlechter 4,0) kann sich Ihre Gesamtnote verschlechtern.

Beispiel: Sie haben in der Klausur eine 4.0 erhalten und keine Programmieraufgaben eingereicht. So ergibt dies insgesamt eine Note schlechter als 4,0 wodurch der Kurs als nicht bestanden gewertet wird. 

Sollten Sie die Klausur nicht bestehen, werden Ihnen die Ãœbungsaufgaben fÃ¼r das kommende Semester **nicht** angerechnet. Die Abgaben sind erneut einzureichen.

**Zusammenarbeit**

 Programmieraufgaben sind in der zugeteilten Gruppe zu bearbeiten. Bei Gruppenabgaben werden alle Team-Mitglieder gleichermaÃŸen bewertet, auÃŸer mind. ein Team-Mitglied beschwert sich hinsichtlich der Bewertung. In diesem Fall findet anstelle dessen eine individuelle Bewertung statt.

Es wird empfohlen auch die Ãœbungsaufgaben aus dem Buch in Gruppen zu erarbeiten und zu diskutieren. 
Lediglich bei den Tutorials empfiehlt es sich diese zunÃ¤chst im Selbststudium zu erschlieÃŸen, bevor diese in der Gruppe be- oder nachbearbeitet werden.

**Lizenz**

Sofern nicht anders angegeben, steht das gesamte Kursmaterial unter einer [Creative Commons Namensnennung 4.0 International Lizenz](https://creativecommons.org/licenses/by/4.0/). 


















### Round Robin (Forts.)



---



---




### Wiederholung














---









## Scheduler Teil 3

### Lottery Scheduling

### Lernziele und Kompetenzen

* Grundlagen des Lottery-Scheduling-Verfahrens **kennen lernen** 

### Proportional / Fair Share Scheduler

* Anstelle Turnaround-Zeiten zu optimieren, versuchen Fair Share Scheduler sicherzustellen, dass jeder Job einen gewissen Prozentsatz der CPU-Ressourcen erhÃ¤lt

* Beispiel: Lottery Scheduling
* Grundidee: Es werden Tickets vergeben, die wie in einer Lotterie gezogen werden
* Prozesse, die Ã¶fters laufen sollen, erhalten schlicht mehr Lotterieloseâ€¦ 

Einfach, oder? ğŸ¤”

### Grundkonzept: Tickets represent your share

* Grundlegendes Konzept: Es werden Tickets vergeben (entsprechen einem CPU Share)
* Beispiel:

  * Job A erhÃ¤lt 75% der Tickets (hier: Lose 0..74)
  * Job B erhÃ¤lt  25%  der Tickets (hier: Lose 75..99)
  * Scheduler muss nun wissen, wie viele Lose es insgesamt gibt (hier: 100)
  * Gewinnerticket gibt an, welcher Prozess lÃ¤uft

![](img/os.05.tickets.png)


### Lottery Scheduler - Ãœberlegungen

* Statistische AnnÃ¤herung an gewÃ¼nschte Aufteilung 
* Je lÃ¤nger die Jobs laufen, desto besser ist die AnnÃ¤herung 
* Was ist bei einer Verteilung 99% zu 1%?
* Man benÃ¶tigt einen guten Zufallsgenerator
* Was macht man wenn ein neuer Job dazu kommt? 


### Ticket WÃ¤hrung

User mit mehreren Tickets, kann diese einer eigene Â»WÃ¤hrungÂ« zuordnen 

* Beispiel

  * A und B haben je 100 Tickets 
  * A hat zwei Jobs, A1 und A2, jeder Job bekommt 500 (von insg. 1.000) User Tickets in Aâ€˜s WÃ¤hrung 
  * B hat 1 Job B1, dieser bekommt 10 von 10 (User Tickets) in Bâ€˜s WÃ¤hrung
  * System konvertiert Aâ€˜s Tickets pro Job zu je 50 Tickets in der SystemwÃ¤hrung
  * System konvertiert Bâ€˜s Ticktes zu 100 Tickets in SystemwÃ¤hrung

### Ticket Transfer

Prozess kann temporÃ¤r Tickets auf einen anderen Prozess Ã¼bertragen

* Beispiel: 

  * Client-Server Mechanismus (lokal)
  * Client, der eine Anfrage von einem Server wartet, kann seine Tickets dem Server geben, um die Antwort zu beschleunigen 
  * Nach Beendigung gibt der Server die Tickets an den Client zurÃ¼ck 

### Linux Completely Fair Scheduler (CFS)

* Problem: Scheduling kann bis zu 5% der CPU-Ressource ausmachen 
* CFS fÃ¼hrt eine virtual runtime (*vruntime*) ein
* Jeder Prozess, der lÃ¤uft, sammelt *vruntime* an
Bei Scheduling-Entscheidung wÃ¤hlt der Scheduler den Prozess mit der geringsten vruntime aus

### CFS: Wie oft sollte ein Prozess gewechselt werden?

* *sched_latency*

  * Time Slice Dauer, typischerweise 48ms 
  * Wird durch Anzahl der Prozesse *n* geteilt
  * Ergibt die Zeitscheibe pro Prozess
  * Somit ist die Zeitverteilung vollstÃ¤ndig fair 

* *min_granularity*

  * Mindestdauer, typischerweise 6ms
  *  Dieser Wert wird niemals unterschritten (Bsp. 10 Prozesse ergÃ¤be 4,8ms pro Prozess)

* CFS nutzt regelmÃ¤ÃŸige Timer Interrupts, der Scheduler kann Entscheidungen also immer nur zu fixen Zeitpunkten treffen

---

### CFS - Beispiel

* Vier Jobs (A,B,C,D), wobei B, C und D kurz nach A eintreffen
* Nach der ersten Zeitscheibe wird einer der Jobs aus (B,C,D) gewÃ¤hlt da hier vruntime von B, C und D < vruntime von A
* Nach *t = 100* sind C und D fertig, danach wird die vruntime zwischen A und B aufgeteilt 

![](img/os.05.cfs.png)

### CFS - Weighting / Niceness

CFS ermÃ¶glicht die Angabe von PrioritÃ¤ten, damit Prozesse mehr CPU-Ressourcen erhalten kÃ¶nnen. 

* In UNIX entspricht das dem Â»nice levelÂ«
* Kann zwischen -20 und + 19 gesetzt werden
* 0 ist Standardwert
* < 0 hÃ¶here Prio, > 0 kleinere Prio

### CFS: Zeitscheibe berechnen

* Gewichtungen erlauben es die Zeitscheibe pro Prozess zu berechnen:

$$
time\_sclice_k = \frac{weight_k}{\sum\limits_{i=0}^{n}weight_i}\cdot sched\_latency
$$

* Beispiel:

  * 2 Prozesse A (Prio=-5), B (Prio=0)
  * $ğ‘¤ğ‘’ğ‘–ğ‘”â„ğ‘¡_ğ´$  = 3121, $ğ‘¤ğ‘’ğ‘–ğ‘”â„ğ‘¡_ğµ$=1024    
  * A erhÃ¤lt 36ms, B erhÃ¤lt 12ms

### prio_to_weight

![](img/os.05.prio_to_weight.png)

### CFS: vruntime berechnen

* Berechnet wieviel Laufzeit ein Prozess imVerhÃ¤ltnis zur Gewichtung genutzt hat

$$
vruntime_i = vruntime\cdot \frac{weight_0}{weight_i} \cdot runtime_i
$$

* Hinweis:

  * Gewichtung bleibt im VerhÃ¤ltnis gleich, wenn andere PrioritÃ¤ten gewÃ¤hlt werden
  * Annahme A hat 5 und B hat 10
  * A und B werden noch im selben VerhÃ¤ltnis wie zuvor gescheduled


### CFS Prozesslisten

* Problem: Bei mehreren hundert oder gar 1.000 Prozessen, wie wird der nÃ¤chste Prozess gefunden?
* Kurzes Gedankenspiel: Skalieren Listen? Hier mÃ¼ssten man immer aller linear durchsuchen, was in einem linearen Aufwand von $ğ‘‚(ğ‘›)$ resultiert.  
* LÃ¶sung: Geschickte Wahl der Datenstruktur:

  * CFS speichert Prozesse in Rot-Schwarz-BÃ¤umen (ausgeglichener Baum)
  * Algorithmen auf Rot-Schwarz-BÃ¤umen sind logarithmisch mit einem Aufwand von $ğ‘‚(lğ‘œğ‘”_ğ‘›)$ 

* Deswegen: Algorithmen und Datenstrukturen

### CFS und I/O

* Was passiert eigentlich wenn ein Prozess A permanent lÃ¤uft, weil B aufgrund einer I/O-Operation blockiert (z.B. 10s)?
* B wacht auf und hat die niedrigste vruntime (10s kleiner als bei A)
* B wÃ¼rde nun die CPU fÃ¼r 10s monopolisieren, Â»StarvationÂ« von A wÃ¤re potentiell mÃ¶glich

* LÃ¶sung: CFS setzt die *vruntime* zurÃ¼ck

  * Sobald ein Job aufwacht, erhÃ¤lt er den Minimum Wert im Baum (Liste aller laufende Jobs)
  * Â»StarvationÂ« wird vermieden
  * Nachteil: Jobs, die nur kurz schlafen, bekommen hierdurch keinen fairen Anteil   

### Abschluss

* Am Beispiel des CFS sieht man, dass die Wahl einer geeigneten Datenstruktur eine signifikante Auswirkung auf ein System haben kann 
* Deswegen macht es durchaus Sinn, sich mit dem Thema *Algorithmen und Datenstrukturen* in SEB3 auseinanderzusetzen

### Referenzen 

[1]	By Cburnett - Own work, CC BY-SA 3.0, https://commons.wikimedia.org/w/index.php?curid=1508398


## Hausaufgaben

### Einheit 1 (Git)

- Udacity Kurs zum Thema Git:Â [https://www.udacity.com/course/version-control-with-git--ud123]https://www.udacity.com/course/version-control-with-git--ud123
- 1x in GitLab (https://git.it.hs-heilbronn.de) anmelden
- C-Crashkurs durcharbeiten: https://github.com/aheil/hhn-c

### Einheit 2 (Prozess API)

- Bearbeiten Sie die Ãœbungsaufgaben zum Thema Process API aus dem OSTEP-Buch [https://pages.cs.wisc.edu/~remzi/OSTEP/cpu-api.pdf](https://pages.cs.wisc.edu/~remzi/OSTEP/cpu-api.pdf)
