# Einheit 10: Input / Ouput

## Lernziele

* **Verstehen** wie I/O Devices grunds√§tzlich aufgebaut sind und wie sich diese in das Betriebssystem integrieren

## Bus-Systeme

* Was w√§re ein Programm ohne Eingabe? Es lieferte immer die gleiche Antwort.
* Was w√§re ein Programm ohne Ausgabe? ü§î
* Ein- und Ausgabe stellt somit einen zentralen Aspekt von Rechnern dar.
* Wie l√§sst sich Ein- und Ausgabe in ein System integrieren?
* Was sind die grundlegenden Mechanismen ?
* Wie k√∂nnen diese effizient umgesetzt werden?
* Welche Aufgabe hat hierbei das Betriebssystem?

### Anbindung

Zun√§chst stellt sich die Frage, wie ein Ger√§t an den Rechner angebunden wird...

* Normalerweise √ºber ein **Bus**
* Wir unterscheiden zwischen
  * **Speicherbus** zur schnellen Anbindung des Hauptspeichers
  * Einem **allgemeinen I/O-Bus** zur systeminternen Kommunikation (bei modernen Ger√§ten ist dies PCI)
  * **Peripherie-Bus** (z.B. SCSI, SATA oder USB)
* Warum aber brauchen wir mehrere solche Bus-Systeme?
* Grund ist die Physik, die Kosten sind hier die ma√ügeblichen Gr√∂√üen
  * Je schneller der Bus, desto k√ºrzer
  * Je schneller der Bus, desto teurer

## **Ein-/Ausgabeger√§te**

Ger√§te zur Ein- und Ausgaben (engl. input/output devices, oder kurz I/O devices) h√§ngen stark von der Systemarchitektur ab.

* Wie sollte I/O grunds√§tzlich in das System integriert werden?
* Was sind die grundlegenden Mechanismen?
* Wie k√∂nnen I/O-Operationen effizient gehandhabt werden?

<figure><img src=".gitbook/assets/os.10.io.de.png" alt=""><figcaption></figcaption></figure>

### **I/O Chips**

* Moderne Architekturen nutzen daher spezielle I/O Chips zum schnellen Routen von Daten
* Beispiel f√ºr einen solchen Chip ist Intel DMI (Direct Media Interface)
* Anbindung von Festplatten via eSATA (external SATA) als Weiterentwicklung von SATA (Serial ATA) als Weiterentwicklung von ATA bzw. IBM AT Attachment (2. IBM PC Generation mit 6 MHz Intel 80286 CPUs)
* USB ‚Äì Universal Serial Bus f√ºr sog. Low Performance Devices



<figure><img src=".gitbook/assets/os.10.bus.de.png" alt=""><figcaption></figcaption></figure>

## Canonical Device

* Grundlegendes (allgemeing√ºltiges) Konzept eines Ger√§tes
  * Besteht aus zwei wichtigen Komponenten:
  * Hardware Interface, √ºber den das das Ger√§t angesteuert werden kann
* Was steckt alles in einem Ger√§t?
  * Stark Implementierungsabh√§ngig
  * Ein paar Chips, komplexere Ger√§te sogar mit einer eigenen CPU
  * Allgemeiner Speicher und weitere Chips\


<figure><img src=".gitbook/assets/os.10.canonical_device.de.png" alt=""><figcaption></figcaption></figure>

## Canonical Protocol

Ben√∂tigt wird ein allgemeing√ºltiges Protokoll zur Ansteuerung von I/O-Ger√§ten.

* Im Beispiel zuvor: 3 Register
  * Status Register: Erm√∂glicht es, den Status des Ger√§ts auszulesen
  * Command Register: Erm√∂glicht es, dem Ger√§t mitzuteilen, welche Aktion als n√§chstes ausgef√ºhrt werden soll
  * Data Register: Erm√∂glicht es Daten ins Ger√§t zu √ºbermitteln
  * Durch Schreiben/Lesen dieser Register wird die Interkation mit dem Ger√§t erm√∂glicht

### **Das Protokoll in 4 Schritten**

1. Warten bis das Ger√§t bereit ist
2. Daten in Register schreiben
3. Kommando in Register schreiben
4. Warten bis Ger√§t fertig ist



```
//while (STATUS == BUSY) ; // wait until device is not busy
write data to DATA register
write command to COMMAND register
(starts the device and executes the command)
while (STATUS == BUSY) ;
// wait until device is done with your request
```

### Polling

* Das Status Register fortw√§hrend auszulesen, wird auch **Polling** genannt
* Im Grund wird andauernd gefragt: ‚ÄûEy Digga, was geht?!‚Äú
* Abh√§ngig von der Gr√∂√üe des Daten Registers sind hier mehrere Durchl√§ufe erforderlich, bis alle Daten geschrieben sind

### **PIO**

Kennt man vom Arduino oder Raspberry PI... aber was steckt dahinter?

* Sobald die CPU (hier meinen wir die CPU vom Rechner, nicht vom I/O Ger√§t) f√ºr das "Hin- und Herschippern" der Daten genutzt wird, sprechen wir von &#x50;_**rogrammed I/O**_ (Abk. PIO)
  * Das Canonical Protokoll funktioniert im Grunde ABER
  * Polling ist kostenintensiv
    * es verschwendet CPU Cycles
    * es verlangsamt oder blockiert die Ausf√ºhrung anderer Prozesse
    * es f√ºhrt die Idee des Overlapping beim Scheduling ad absurdum

### **Interrupts** 

* Idee: Den CPU Overhead mittels Interrupts reduzieren
* Grunds√§tzliche Funktionsweise:
  * Betriebssystem stellt eine Anfrage an ein Ger√§t
  * Der aufrufende Prozess wird schlafen geschickt
  * Betriebssystem f√ºhrt einen Kontext-Switch zu einem anderen Prozess aus
  * Sobald das Ger√§t fertig ist, wird ein Hardware Interrupt ausgel√∂st
  * Der Interrupt veranlasst das Betriebssystem eine vordefinierten _Interrupt Service Routine_ (ISR) bzw. _Interrupt Handler_ auszuf√ºhren.

### **Polling vs Interrupts**

In dem ersten Beispiel pollt die CPU, bis das Ger√§t fertig ist.

Mit einem Interrupt k√∂nnte die CPU in der Zwischenzeit etwas anders (sinnvolles) machen (zweites Beispiel).\


<figure><img src=".gitbook/assets/os.10.polling.de.png" alt=""><figcaption></figcaption></figure>

### **Performance**

* Interrupts sind nicht immer die beste L√∂sung
  * Wenn das Ger√§t so schnell ist, dass beim ersten Poll die Antwort k√§me, machen Interrupts das System langsamer
  * Der damit zusammenh√§ngenden Context Switch ist im Verh√§ltnis zum ‚Äûkurz Warten‚Äú teurer

### **Livelocks** 

Zu viele Interrupts k√∂nnen das System auch √ºberlasten

In diesem Fall sprechen wir von einem _Livelock._

<figure><img src=".gitbook/assets/os.10.livelock.de.png" alt=""><figcaption></figcaption></figure>

### **L√∂sungsidee: Hybrid Ansatz**

Die L√∂sung zum, vorherigen Problem: Zwei Phasen

* F√ºr einen kurzen Zeitraum pollen
* Wenn das Ger√§t nicht geantwortet hat einen Interrupt nutzen

Ein konkretes Beispiel:Ein Web-Server erh√§lt pl√∂tzlich (extrem) viele Anfragen. Wenn nun bei eintreffenden Paketen nur noch Interrupts ausgel√∂st werden, l√§uft im Prinzip kein Prozess mehr im User-Space. Daher w√§re es besser den Web-Server selbst entscheiden zu lassen wann er neue Pakete entgegen nimmt.

### **Alternativer L√∂sungsansatz: Coalesing**

> Nachteil: Zu langes Warten kann zu einer erh√∂hten Latenz des Ger√§tes f√ºhren

* Wenn ein Ger√§t fertig ist, wird der Interrupt nicht sofort ausgel√∂st!
  * Anstelle dessen wartet das Ger√§t einen Moment ob bzw. bis weiter Anfragen abgearbeitet sind
  * Nun werden alle bearbeitet Requests geb√ºndelt zur√ºck geliefert, in dem der Interrupt nur einmal ausgel√∂st wird

## DMA

Nicht nur das Polling auch bei anderen Aufgaben wird die CPU f√ºr eigentlich triviale Aufgaben in Anspruch genommen: z.B. das Kopieren von Daten in die Daten Register.

> Frage: Wie kann der CPU Arbeit abgenommen werden, damit die CPU effizienter genutzt werden kann? Ganz einfach: Kopieren der Daten

\
**DMA: Direct Memory Access**

* Eine separate DMA Engine orchestriert den Datenfluss zwischen Ger√§t und Hauptspeicher
  * Funktionsweise: Das Betriebssystem programmiert die DMA Engine mit
    * Speicherort an dem die Daten liegen
    * Wie viele Daten kopiert werden sollen
    * An welches Ger√§t die Daten geschickt werden sollen und ist jetzt quasi fertig!

<figure><img src=".gitbook/assets/os.10.dma.de.png" alt=""><figcaption></figcaption></figure>

## Kommunikation mit dem Ger√§t

Nun stellt sich noch die Frage, wie die ganzen Ger√§te mit ihren spezifischen Hardware Interfaces in das Betriebssystem passen?

> Ziel: Betriebssystem so gut wie es geht ger√§teneutral halten, also die Details der Ger√§teinteraktion vom Betriebssystem ‚Äûverstecken‚Äú.

L√∂sung: Wie so oft in der Informatik hilft uns hier die _Abstraktion_!\


<figure><img src=".gitbook/assets/os.10.abstraction.de.png" alt=""><figcaption></figcaption></figure>

### Ger√§tetreiber

Die ger√§tespezifische Funktionalit√§t wird als Ger√§tetreiber ausgeliefert.

Nachteil: Durch die generische Schnittstelle k√∂nnen nicht immer alle (tollen) Funktionen eines Ger√§ts genutzt werden.

Beispiel: SCSI Error-Funktionalit√§t ist unter Linux √ºber die einfachere ATA/DIE Schnittstelle nicht nutzbar.

Bedeutung von Ger√§tetreibern: Bis zu 70% des Codes eines Betriebssystems (Linux und Windows ann√§hernd gleich viel) steckt heute inzwischen in Ger√§tetreibern.

**Problem**: Dieser Code wird nicht von Kernel-Entwicklern gebaut. Fehlern im Ger√§tetreiber, die im Kernel-Mode laufen, k√∂nnen unter Windows einen Bluescreen ([BSoD](https://weblogs.asp.net/wallym/77425)) verursachen. Ob die Ursache an Windows oder einem Ger√§tetreiber lag, ist dem Anwender nicht zwingend ersichtlich.

### Exkurs: Crowdstrike BSoD

Juli 2024 konnten Millionen von PCs aufgrund eines Updates der Firma Crowdstrike nicht mehr starten. Das Problem betraf Flugh√§fen, Warenh√§user, Krankenh√§user und viele weitere Einrichtungen weltweit. Aus der Fehlermeldung war den Anwendern jedoch nicht klar, worin das eigentliche Problem lag. Offensichtlich war: Windows startet nicht mehr.

Das Problem lag in CrowdStrike‚Äôs `csagent.sys` und wurde durch ein fehlerhaftes Update der Sicherheitssoftware verursacht. Dieses Update f√ºhrte dazu, dass mehrere Millionen von Windows-Systemen weltweit nicht mehr gestartet werden konnten. Die betroffenen Ger√§te zeigten einen Bluescreen of Death (BSOD) mit der Fehlermeldung `PAGE_FAULT_IN_NONEPAGED_AREA` an, ausgel√∂st durch die Datei `csagent.sys`.

Erste forensische Analysen des Memory Dumps des Blue Screen of Death (BSOD) deuten darauf hin, dass das Problem auf einen sogenannten Null-Pointer-Fehler in CrowdStrike‚Äôs `csagent.sys` zur√ºckzuf√ºhren ist. Der Code versuchte anscheinend, auf eine ung√ºltige Speicheradresse (`0x9c` bzw`156`) zuzugreifen ([heise.de](https://www.heise.de/hintergrund/Fataler-Fehler-bei-CrowdStrike-Schuld-war-ein-Null-Pointer-9807896.html)).

Eine M√∂glichkeit f√ºr mehr Transparenz, w√§re ein BSoD, der z.B. direkt zur Hersteller-Seite verweist:

<figure><img src=".gitbook/assets/bsod_csagent_crowdstrike_conceptart.jpg" alt=""><figcaption><p>Concept design of a better BoSD. Cleary indicating the cause of the error and pointing to the direct support. Remark: This is a conceptual BSoD, indicated for teaching purposes only. Create with: <a href="https://bsodmaker.net/">https://bsodmaker.net/</a></p></figcaption></figure>



\
